import{g as d}from"./CUAbeyJP.js";function c(e){const t=new Uint8Array(e);let n="";for(const r of t)n+=String.fromCharCode(r);return btoa(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function p(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),n=(4-t.length%4)%4,o=t.padEnd(t.length+n,"="),r=atob(o),a=new ArrayBuffer(r.length),s=new Uint8Array(a);for(let i=0;i<r.length;i++)s[i]=r.charCodeAt(i);return a}function A(){return S.stubThis((globalThis==null?void 0:globalThis.PublicKeyCredential)!==void 0&&typeof globalThis.PublicKeyCredential=="function")}const S={stubThis:e=>e};function R(e){const{id:t}=e;return{...e,id:p(t),transports:e.transports}}function O(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class u extends Error{constructor({message:t,code:n,cause:o,name:r}){super(t,{cause:o}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=r??o.name,this.code=n}}class T{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){const n=new Error("Cancelling existing WebAuthn API call for new one");n.name="AbortError",this.controller.abort(n)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const C=new T,I=["cross-platform","platform"];function P(e){if(e&&!(I.indexOf(e)<0))return e}function W(){if(!A())return h.stubThis(new Promise(t=>t(!1)));const e=globalThis.PublicKeyCredential;return(e==null?void 0:e.isConditionalMediationAvailable)===void 0?h.stubThis(new Promise(t=>t(!1))):h.stubThis(e.isConditionalMediationAvailable())}const h={stubThis:e=>e};function v({error:e,options:t}){const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new u({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new u({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const o=globalThis.location.hostname;if(O(o)){if(n.rpId!==o)return new u({message:`The RP ID "${n.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new u({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new u({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function N(e){var w,b;!e.optionsJSON&&e.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useBrowserAutofill:n=!1,verifyBrowserAutofillInput:o=!0}=e;if(!A())throw new Error("WebAuthn is not supported in this browser");let r;((w=t.allowCredentials)==null?void 0:w.length)!==0&&(r=(b=t.allowCredentials)==null?void 0:b.map(R));const a={...t,challenge:p(t.challenge),allowCredentials:r},s={};if(n){if(!await W())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&o)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');s.mediation="conditional",a.allowCredentials=[]}s.publicKey=a,s.signal=C.createNewAbortSignal();let i;try{i=await navigator.credentials.get(s)}catch(g){throw v({error:g,options:s})}if(!i)throw new Error("Authentication was not completed");const{id:y,rawId:m,response:l,type:E}=i;let f;return l.userHandle&&(f=c(l.userHandle)),{id:y,rawId:c(m),response:{authenticatorData:c(l.authenticatorData),clientDataJSON:c(l.clientDataJSON),signature:c(l.signature),userHandle:f},type:E,clientExtensionResults:i.getClientExtensionResults(),authenticatorAttachment:P(i.authenticatorAttachment)}}async function j(e,t){const n=await fetch("/api/auth/login",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({email:e,password:t}),credentials:"include"});if(!n.ok){const o=await n.json();throw new Error(o.message||"Login failed")}await d("/")}async function D(e,t,n){const o=await fetch("/api/auth/register",{method:"POST",headers:{"Content-Type":"applications/json"},body:JSON.stringify({username:e,email:t,password:n}),credentials:"include"});if(!o.ok){const r=await o.json();throw new Error(r.message||"Registration failed")}await d("/")}async function U(e){const t=await e("/api/user",{method:"GET",headers:{Accept:"application/json"},credentials:"include"});if(t.status===401||t.status===403)throw new Error("Unauthorized");if(!t.ok){const o=await t.json();throw new Error(o.error||"Failed to fetch user")}return(await t.json()).user}async function K(){try{await fetch("/api/auth/logout",{method:"POST",credentials:"include"})}catch(e){console.error("Logout failed:",e)}finally{await d("/portal/login")}}async function J(e){console.log("üîê Starting WebAuthn login for:",e);const t=await fetch("/api/auth/webauthn/login/begin",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({email:e}),credentials:"include"});if(!t.ok){const a=await t.json();throw console.error("‚ùå Failed to start WebAuthn login:",a),new Error(a.error||"WebAuthn login start failed")}const{publicKey:n}=await t.json();if(console.log("üõ†Ô∏è Parsed PublicKey options:",n),!n||!n.challenge)throw console.error("‚ùå Invalid PublicKeyCredentialRequestOptions:",n),new Error("WebAuthn options missing challenge");let o;try{o=await N(n),console.log("‚úÖ Got authentication assertion:",o),console.log("üìå Assertion Credential ID:",o.id)}catch(a){throw console.error("‚ùå WebAuthn browser interaction failed:",a),new Error(`WebAuthn interaction failed: ${a.message}`)}const r=await fetch("/api/auth/webauthn/login/finish",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({...o,email:e}),credentials:"include"});if(!r.ok){const a=await r.json();throw console.error("‚ùå WebAuthn verification failed:",a),new Error(a.error||"WebAuthn login failed")}console.log("üéâ WebAuthn login successful"),await d("/")}export{u as W,p as a,A as b,C as c,c as d,P as e,K as f,U as g,O as i,j as l,D as r,R as t,J as w};
